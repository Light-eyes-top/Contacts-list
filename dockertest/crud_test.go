package dockertest

import (
	someRestApi "SomeRestApi"
	"SomeRestApi/dockertest/testConfig"
	"SomeRestApi/internal/config"
	handler "SomeRestApi/internal/handlers/hendler_REST"
	"SomeRestApi/internal/repository"
	"SomeRestApi/internal/repository/postgres"
	"SomeRestApi/internal/service"
	"encoding/json"
	"fmt"
	_ "github.com/jackc/pgx/v5/stdlib"
	"github.com/jmoiron/sqlx"
	"github.com/ory/dockertest/v3"
	"github.com/ory/dockertest/v3/docker"
	"github.com/stretchr/testify/require"
	"log"
	"net/http"
	"os"
	"testing"
	"time"
)

var db *sqlx.DB

var cfgDocker = testConfig.ConfigDocker{
	TestUser:       "postgres",
	TestPassword:   "password",
	TestDbname:     "testDb",
	TestHost:       "localhost",
	TestDbPort:     "5436",
	TestServerPort: "8000",
}

var options = dockertest.RunOptions{
	Repository: "postgres",
	Tag:        "latest",
	Env: []string{
		"POSTGRES_USER=" + cfgDocker.TestUser,
		"POSTGRES_PASSWORD=" + cfgDocker.TestPassword,
		"POSTGRES_DB=" + cfgDocker.TestDbname,
	},
	ExposedPorts: []string{"5432"},
	PortBindings: map[docker.Port][]docker.PortBinding{
		"5432": {
			{HostIP: "0.0.0.0", HostPort: cfgDocker.TestDbPort},
		},
	},
}

func DockerAndPostgresSetup() (*dockertest.Pool, *dockertest.Resource) {
	pool, err := dockertest.NewPool("")
	if err != nil {
		log.Fatalf("Could not construct pool: %s", err)
	}

	err = pool.Client.Ping()
	if err != nil {
		log.Fatalf("Could not connect to Docker: %s", err)
	}

	resource, err := pool.RunWithOptions(&options, func(config *docker.HostConfig) { config.AutoRemove = true })
	if err != nil {
		log.Panicf("Could not start resource: %s", err)
	}

	databaseUrl := fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=disable", cfgDocker.TestUser,
		cfgDocker.TestPassword, cfgDocker.TestHost, cfgDocker.TestDbPort, cfgDocker.TestDbname)

	log.Println("Connecting to database on url: ", databaseUrl)

	resource.Expire(60)

	pool.MaxWait = 60 * time.Second
	if err = pool.Retry(func() error {
		db, err = sqlx.Open("pgx", databaseUrl)
		if err != nil {
			log.Println(err)
			return err
		}
		log.Println(db.Ping())
		return db.Ping()
	}); err != nil {
		log.Fatalf("Could not connect to database: %s", err)
	}

	query := fmt.Sprintf("CREATE TABLE contacts(" +
		"id    bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY," +
		"fio   text not null," +
		"email text not null," +
		"phone text not null)")
	_, err = db.Exec(query)
	if err != nil {
		log.Fatalf("migrashion failed: %s", err)
	}
	return pool, resource
}

func ServerSetup() {
	cfgServer := config.Config{
		Postgres: config.Postgres{
			User:     cfgDocker.TestUser,
			Port:     cfgDocker.TestDbPort,
			Password: cfgDocker.TestPassword,
			Host:     cfgDocker.TestHost,
			Dbname:   cfgDocker.TestDbname,
			Sslmode:  "disable",
		},
		Server: config.Server{
			PortREST: cfgDocker.TestServerPort,
		},
		SaveType: "postgres",
	}

	var repos *repository.Repository
	if cfgServer.SaveType == "postgres" {
		db, err := postgres.InitConnect(cfgServer.Postgres)
		if err != nil {
			log.Fatalf("error initializing datatbase: %s", err.Error())
		}
		repos = repository.NewRepositoryPostgres(db)
	} else {
		repos = repository.NewRepositoryInMemory()
	}

	services := service.NewService(repos)
	handlers := handler.NewHandler(services)

	srv := new(someRestApi.Server)
	if err := srv.Run(cfgServer.Server.PortREST, handlers.InitRoutes()); err != nil {
		log.Fatalf("error occured while running http server: %s", err.Error())
	}
}

func TestMain(m *testing.M) {
	pool, resource := DockerAndPostgresSetup()
	go ServerSetup()
	code := m.Run()
	os.Exit(code)

	if err := pool.Purge(resource); err != nil {
		log.Fatalf("Could not purge resource: %s", err)
	}
}

func TestCRUD(t *testing.T) {
	type Contacts struct {
		Fio   string `json:"fio"`
		Email string `json:"email"`
		Phone string `json:"phone"`
	}
	client := &HttpClient{}

	contact := Contacts{
		Fio:   "Jack",
		Email: "111@gmail.com",
		Phone: "123",
	}

	var (
		resp     *http.Response
		respBody []byte
	)

	httpBody, err := json.Marshal(contact)
	require.NoError(t, err)

	t.Run("CREATE", func(t *testing.T) {
		for attempt := 0; attempt < 20; attempt++ {
			resp, respBody, err = client.SendJsonReq("POST", "http://localhost:8000/contact/post", httpBody)
			require.NoError(t, err)
			if err != nil {
				t.Log(fmt.Sprintf("client.sendJsonReq failed: %v, waiting... (attempt %d)",
					err, attempt))
				time.Sleep(1 * time.Second)
				continue
			}
			break
		}

		require.Equal(t, 200, resp.StatusCode)
		require.NotEqual(t, "", string(respBody))
	})

	t.Run("READ", func(t *testing.T) {
		resp, respBody, err = client.SendJsonReq("GET", "http://localhost:8000/contact/get/1", httpBody)
		require.NoError(t, err)
		require.Equal(t, 200, resp.StatusCode)

		err = json.Unmarshal(respBody, &contact)
		require.NoError(t, err)
		require.Equal(t, "Jack", contact.Fio)
		require.Equal(t, "111@gmail.com", contact.Email)
		require.Equal(t, "123", contact.Phone)
	})

	t.Run("UPDATE", func(t *testing.T) {
		contact.Fio = "Tema"
		contact.Email = "69@gay.ass"
		contact.Phone = "321"
		httpBody, err = json.Marshal(contact)
		require.NoError(t, err)

		resp, respBody, err = client.SendJsonReq("PUT", "http://localhost:8000/contact/put/1", httpBody)
		require.NoError(t, err)
		require.Equal(t, 200, resp.StatusCode)

		err = json.Unmarshal(respBody, &contact)
		require.NoError(t, err)
		require.Equal(t, "Tema", contact.Fio)
		require.Equal(t, "69@gay.ass", contact.Email)
		require.Equal(t, "321", contact.Phone)
	})

	t.Run("DELETE", func(t *testing.T) {
		resp, respBody, err = client.SendJsonReq("DELETE", "http://localhost:8000/contact/delete/1", httpBody)
		require.NoError(t, err)
		require.Equal(t, 200, resp.StatusCode)

		resp, respBody, err = client.SendJsonReq("GET", "http://localhost:8000/contact/get/1", httpBody)
		require.NoError(t, err)
		require.Equal(t, 500, resp.StatusCode)
	})
}
